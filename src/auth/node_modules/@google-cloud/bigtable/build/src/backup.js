"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backup = void 0;
const precise_date_1 = require("@google-cloud/precise-date");
const promisify_1 = require("@google-cloud/promisify");
const snakeCase = require("lodash.snakecase");
const table_1 = require("../src/table");
const instance_1 = require("./instance");
/**
 * Interact with backups like get detailed information from BigTable, create
 * a backup, or restore a backup to a table.
 *
 * @class
 * @param {Cluster} cluster The parent instance of this backup.
 * @param {string} name Name of the backup.
 *
 * @example
 * ```
 * const {Bigtable} = require('@google-cloud/bigtable');
 * const bigtable = new Bigtable();
 * const instance = bigtable.instance('my-instance');
 * const cluster = instance.cluster('my-cluster');
 * const backup = cluster.backup('my-backup');
 * ```
 */
class Backup {
    /**
     * @param {Cluster} cluster
     * @param {string} id The backup name or id.
     */
    constructor(cluster, id) {
        this.bigtable = cluster.bigtable;
        this.cluster = cluster;
        if (id.includes('/')) {
            if (id.startsWith(cluster.name)) {
                this.name = id;
                this.id = id.split('/').pop();
            }
            else {
                throw new Error(`Backup id '${id}' is not formatted correctly.
Please use the format 'my-backup' or '${cluster.name}/backups/my-backup'.`);
            }
        }
        else {
            this.name = `${this.cluster.name}/backups/${id}`;
            this.id = id;
        }
    }
    /**
     * A Date-compatible PreciseDate representing the time that the backup was
     * finished.
     * @readonly
     * @return {PreciseDate}
     */
    get endDate() {
        if (!this.metadata || !this.metadata.endTime) {
            throw new TypeError('An endTime is required to convert to Date.');
        }
        return new precise_date_1.PreciseDate({
            seconds: this.metadata.endTime.seconds,
            nanos: this.metadata.endTime.nanos,
        });
    }
    /**
     * A Date-compatible PreciseDate representing the expiration time of this
     * backup.
     * @readonly
     * @return {PreciseDate}
     */
    get expireDate() {
        if (!this.metadata || !this.metadata.expireTime) {
            throw new TypeError('An expireTime is required to convert to Date.');
        }
        return new precise_date_1.PreciseDate({
            seconds: this.metadata.expireTime.seconds,
            nanos: this.metadata.expireTime.nanos,
        });
    }
    /**
     * A Date-compatible PreciseDate representing the time that this backup was
     * started.
     * @readonly
     * @return {PreciseDate}
     */
    get startDate() {
        if (!this.metadata || !this.metadata.startTime) {
            throw new TypeError('A startTime is required to convert to Date.');
        }
        return new precise_date_1.PreciseDate({
            seconds: this.metadata.startTime.seconds,
            nanos: this.metadata.startTime.nanos,
        });
    }
    /**
     * Starts creating a new Cloud Bigtable Backup.
     *
     * The returned {@link google.longrunning.Operation|long-running operation}
     * can be used to track creation of the backup. Cancelling the returned
     * operation will stop the creation and delete the backup.
     *
     * @param {CreateBackupConfig} config Configuration object.
     * @param {BackupTimestamp} config.expireTime When the backup will be
     *     automatically deleted.
     * @param {string|Table} config.table Table to create the backup from.
     * @param {CallOptions} [config.gaxOptions] Request configuration options,
     *     outlined here:
     *     https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @param {CreateBackupCallback} [callback] The callback function.
     * @param {?error} callback.err An error returned while making this request.
     * @param {Backup} callback.backup The newly created Backup.
     * @param {Operation} callback.operation An operation object that can be used
     *     to check the status of the request.
     * @param {object} callback.apiResponse The full API response.
     * @return {void | Promise<CreateBackupResponse>}
     *
     * @example <caption>include:samples/api-reference-doc-snippets/backups.create.js</caption>
     * region_tag:bigtable_api_create_backup
     */
    create(config, callback) {
        this.cluster.createBackup(this.id, config, callback);
    }
    /**
     * Deletes this pending or completed Cloud Bigtable backup.
     *
     * @param {CallOptions | DeleteBackupCallback} [gaxOptionsOrCallback]
     * @param {DeleteBackupCallback} [callback] The callback function.
     * @param {?error} callback.err An error returned while making this request.
     * @param {object} callback.apiResponse The full API response.
     * @return {void | Promise<DeleteBackupResponse>}
     *
     * @example <caption>include:samples/api-reference-doc-snippets/backups.delete.js</caption>
     * region_tag:bigtable_api_delete_backup
     */
    delete(gaxOptionsOrCallback, cb) {
        const gaxOpts = typeof gaxOptionsOrCallback === 'object' ? gaxOptionsOrCallback : {};
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        this.bigtable.request({
            client: 'BigtableTableAdminClient',
            method: 'deleteBackup',
            reqOpts: {
                name: this.name,
            },
            gaxOpts,
        }, callback);
    }
    /**
     * Check if a backup exists.
     *
     * @param {object} [gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @param {function} callback The callback function.
     * @param {?error} callback.err An error returned while making this
     *     request.
     * @param {boolean} callback.exists Whether the backup exists or not.
     */
    exists(optionsOrCallback, cb) {
        const gaxOptions = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.getMetadata(gaxOptions, err => {
            if (err) {
                if (err.code === 5) {
                    callback(null, false);
                    return;
                }
                callback(err);
                return;
            }
            callback(null, true);
        });
    }
    /**
     * Get a backup if it exists.
     *
     * @param {object} [gaxOptions] Request configuration options, outlined here:
     *     https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @param {function} callback The callback function.
     * @param {?error} callback.err An error returned while making this
     *     request.
     * @param {Backup} callback.backup The Backup instance.
     * @param {object} callback.apiResponse The full API response.
     *
     * @example <caption>include:samples/api-reference-doc-snippets/backups.get.js</caption>
     * region_tag:bigtable_api_get_backup
     */
    get(gaxOptionsOrCallback, cb) {
        const gaxOpts = typeof gaxOptionsOrCallback === 'object' ? gaxOptionsOrCallback : {};
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        this.getMetadata(gaxOpts, (err, metadata) => {
            callback(err, err ? null : this, metadata);
        });
    }
    /**
     * @param {object} [options] Configuration object.
     * @param {object} [options.gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @param {number} [options.requestedPolicyVersion] The policy format version
     *     to be returned. Valid values are 0, 1, and 3. Requests specifying an
     *     invalid value will be rejected. Requests for policies with any
     *     conditional bindings must specify version 3. Policies without any
     *     conditional bindings may specify any valid value or leave the field unset.
     * @param {function} [cb] The callback function.
     * @param {?error} callback.error An error returned while making this request.
     * @param {Policy} policy The policy.
     *
     * @example <caption>include:samples/api-reference-doc-snippets/instance.js</caption>
     * region_tag:bigtable_api_get_table_Iam_policy
     */
    getIamPolicy(optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        table_1.Table.prototype.getIamPolicy.call(this, options, callback);
    }
    /**
     * Get a backup if it exists.
     *
     * @param {object} [gaxOptions] Request configuration options, outlined here:
     *     https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @param {function} callback The callback function.
     * @param {?error} callback.err An error returned while making this
     *     request.
     * @param {object} callback.metadata The metadata.
     * @param {object} callback.apiResponse The full API response.
     *
     * @example <caption>include:samples/api-reference-doc-snippets/backups.get.js</caption>
     * region_tag:bigtable_api_get_backup
     */
    getMetadata(gaxOptionsOrCallback, cb) {
        const gaxOpts = typeof gaxOptionsOrCallback === 'object' ? gaxOptionsOrCallback : {};
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        this.bigtable.request({
            client: 'BigtableTableAdminClient',
            method: 'getBackup',
            reqOpts: {
                name: this.name,
            },
            gaxOpts,
        }, (err, resp) => {
            if (resp) {
                this.metadata = resp;
            }
            callback(err, resp);
        });
    }
    /**
     * Create a new table by restoring from this completed backup.
     *
     * The new table must be in the same instance as the instance containing
     * the backup. The returned
     * {@link google.longrunning.Operation|long-running operation} can be used
     * to track the progress of the operation, and to cancel it.
     *
     * @param {string} tableId The id of the table to create and restore to. This
     *   table must not already exist.
     * @param {CallOptions | RestoreTableCallback} [gaxOptionsOrCallback]
     * @param {RestoreTableCallback} [callback] The callback function.
     * @param {?error} callback.err An error returned while making this request.
     * @param {Table} callback.table The newly created Table.
     * @param {Operation} callback.operation An operation object that can be used
     *     to check the status of the request.
     * @param {object} callback.apiResponse The full API response.
     * @return {void | Promise<RestoreTableResponse>}
     *
     * @example <caption>include:samples/api-reference-doc-snippets/backups.restore.js</caption>
     * region_tag:bigtable_api_restore_backup
     */
    restore(tableId, gaxOptionsOrCallback, cb) {
        const gaxOpts = typeof gaxOptionsOrCallback === 'object'
            ? gaxOptionsOrCallback
            : undefined;
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        this.restoreTo({
            tableId,
            instance: this.cluster.instance,
            gaxOptions: gaxOpts,
        }, callback);
    }
    /**
     * Create a new table by restoring from this completed backup.
     *
     * The returned
     * {@link google.longrunning.Operation|long-running operation} can be used
     * to track the progress of the operation, and to cancel it.
     *
     * @param {RestoreTableConfig} config Configuration object.
     * @param {string} tableId The id of the table to create and restore to. This
     *     table must not already exist.
     * @param {Instance|string} [instance] Instance in which the new table will
     *     be created and restored to. Instance must be in the same project as the
     *     project containing backup.
     *     If omitted the instance containing the backup will be used instead.
     * @param {CallOptions} [gaxOptions] Request configuration options,
     *     outlined here:
     *     https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html.
     * @param {RestoreTableCallback} [callback] The callback function.
     * @param {?error} callback.err An error returned while making this request.
     * @param {Table} callback.table The newly created Table.
     * @param {Operation} callback.operation An operation object that can be used
     *     to check the status of the request.
     * @param {object} callback.apiResponse The full API response.
     * @return {void | Promise<RestoreTableResponse>}
     */
    restoreTo(config, callback) {
        let parent;
        if (config.instance) {
            if (config.instance instanceof instance_1.Instance) {
                parent = config.instance.name;
            }
            else {
                parent = this.bigtable.instance(config.instance).name;
            }
        }
        else {
            parent = this.cluster.instance.name;
        }
        this.bigtable.request({
            client: 'BigtableTableAdminClient',
            method: 'restoreTable',
            reqOpts: {
                parent,
                tableId: config.tableId,
                backup: this.name,
            },
            gaxOpts: config.gaxOptions,
        }, (err, ...args) => {
            if (err) {
                callback(err, undefined, ...args);
                return;
            }
            callback(err, this.cluster.instance.table(config.tableId), ...args);
        });
    }
    /**
     * @param {object} [gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @param {function} [callback] The callback function.
     * @param {?error} callback.error An error returned while making this request.
     * @param {Policy} policy The policy.
     *
     * @example <caption>include:samples/api-reference-doc-snippets/instance.js</caption>
     * region_tag:bigtable_api_set_instance_Iam_policy
     */
    setIamPolicy(policy, gaxOptionsOrCallback, cb) {
        const gaxOptions = typeof gaxOptionsOrCallback === 'object' ? gaxOptionsOrCallback : {};
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        table_1.Table.prototype.setIamPolicy.call(this, policy, gaxOptions, callback);
    }
    /**
     * Updates this pending or completed Cloud Bigtable Backup.
     *
     * @param {ModifiableBackupFields} metadata - The fields to be updated.
     * @param {CallOptions | BackupSetMetadataCallback} [gaxOptionsOrCallback]
     * @param {BackupSetMetadataCallback} [callback] The callback function.
     * @param {?error} callback.err An error returned while making this request.
     * @param
     * @param {object} callback.apiResponse The full API response.
     * @return {void | Promise<BackupSetMetadataResponse>}
     *
     * @example <caption>include:samples/api-reference-doc-snippets/backups.update.js</caption>
     * region_tag:bigtable_api_update_backup
     */
    setMetadata(metadata, gaxOptionsOrCallback, cb) {
        const gaxOpts = typeof gaxOptionsOrCallback === 'object' ? gaxOptionsOrCallback : {};
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        const backup = {
            name: this.name,
            ...metadata,
        };
        if (backup.expireTime instanceof Date) {
            backup.expireTime = new precise_date_1.PreciseDate(backup.expireTime).toStruct();
        }
        this.bigtable.request({
            client: 'BigtableTableAdminClient',
            method: 'updateBackup',
            reqOpts: {
                backup,
                updateMask: {
                    paths: Object.keys(metadata).map(snakeCase),
                },
            },
            gaxOpts,
        }, (err, resp) => {
            if (resp) {
                this.metadata = resp;
            }
            callback(err, this.metadata, resp);
        });
    }
    /**
     *
     * @param {string | string[]} permissions The permission(s) to test for.
     * @param {object} [gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @param {function} [callback] The callback function.
     * @param {?error} callback.error An error returned while making this request.
     * @param {string[]} permissions A subset of permissions that the caller is
     *     allowed.
     *
     * @example <caption>include:samples/api-reference-doc-snippets/instance.js</caption>
     * region_tag:bigtable_api_test_table_Iam_permissions
     */
    testIamPermissions(permissions, gaxOptionsOrCallback, cb) {
        const gaxOptions = typeof gaxOptionsOrCallback === 'object' ? gaxOptionsOrCallback : {};
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        table_1.Table.prototype.testIamPermissions.call(this, permissions, gaxOptions, callback);
    }
}
exports.Backup = Backup;
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
promisify_1.promisifyAll(Backup, { exclude: ['endDate', 'expireDate', 'startDate'] });
/**
 * Reference to the {@link Backup} class.
 * @name module:@google-cloud/bigtable.Backup
 * @see Backup
 */
//# sourceMappingURL=backup.js.map