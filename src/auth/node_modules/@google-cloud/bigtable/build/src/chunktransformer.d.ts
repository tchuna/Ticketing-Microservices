/// <reference types="long" />
/// <reference types="node" />
import { Transform, TransformOptions } from 'stream';
import { Bytes } from './mutation';
export declare type Value = string | number | boolean | Uint8Array;
export interface Chunk {
    rowContents: Value;
    commitRow: boolean;
    resetRow: boolean;
    rowKey?: string | Bytes;
    familyName?: {
        value: string;
    };
    qualifier?: Qualifier | {
        value: Value;
    };
    timestampMicros?: number | Long;
    labels?: string[];
    value?: string | Buffer;
    valueSize?: number;
}
export interface Data {
    chunks: Chunk[];
    lastScannedRowKey?: Buffer;
}
interface Family {
    [qualifier: string]: Qualifier[];
}
export interface Qualifier {
    value?: string | Buffer;
    labels?: string[];
    timestamp?: number | Long;
    size?: number;
}
export interface Row {
    key?: Value;
    data?: {
        [index: string]: Family;
    };
}
export interface TransformErrorProps {
    message: string;
    chunk: Chunk | null;
}
/**
 * Enum for chunk formatter Row state.
 * NEW_ROW: initial state or state after commitRow or resetRow
 * ROW_IN_PROGRESS: state after first valid chunk without commitRow or resetRow
 * CELL_IN_PROGRESS: state when valueSize > 0(partial cell)
 */
export declare enum RowStateEnum {
    NEW_ROW = 1,
    ROW_IN_PROGRESS = 2,
    CELL_IN_PROGRESS = 3
}
/**
 * ChunkTransformer formats all incoming chunks in to row
 * keeps all intermediate state until end of stream.
 * Should use new instance for each request.
 */
export declare class ChunkTransformer extends Transform {
    options: TransformOptions;
    _destroyed: boolean;
    lastRowKey?: Value;
    state?: number;
    row?: Row;
    family?: Family;
    qualifiers?: Qualifier[];
    qualifier?: Qualifier;
    constructor(options?: TransformOptions);
    /**
     * called at end of the stream.
     * @public
     * @param {callback} cb callback will be called with error if there is any uncommitted row
     */
    _flush(cb: Function): void;
    /**
     * transform the readrowsresponse chunks into friendly format. Chunks contain
     * 3 properties:
     *
     * `rowContents` The row contents, this essentially is all data pertaining
     *     to a single family.
     *
     * `commitRow` This is a boolean telling us the all previous chunks for this
     *     row are ok to consume.
     *
     * `resetRow` This is a boolean telling us that all the previous chunks are to
     *     be discarded.
     *
     * @public
     *
     * @param {object} data readrows response containing array of chunks.
     * @param {object} [enc] encoding options.
     * @param {callback} next callback will be called once data is processed, with error if any error in processing
     */
    _transform(data: Data, enc: string, next: Function): void;
    /**
     * called when stream is destroyed.
     * @public
     * @param {error} err error if any
     */
    destroy(err?: Error): this;
    /**
     * Resets state of formatter
     * @private
     */
    reset(): void;
    /**
     * sets lastRowkey and calls reset when row is committed.
     * @private
     */
    commit(): void;
    /**
     * Validates valuesize and commitrow in a chunk
     * @private
     * @param {chunk} chunk chunk to validate for valuesize and commitRow
     */
    validateValueSizeAndCommitRow(chunk: Chunk): void;
    /**
     * Validates resetRow condition for chunk
     * @private
     * @param {chunk} chunk chunk to validate for resetrow
     */
    validateResetRow(chunk: Chunk): void;
    /**
     * Validates state for new row.
     * @private
     * @param {chunk} chunk chunk to validate
     * @param {newRowKey} newRowKey newRowKey of the new row
     */
    validateNewRow(chunk: Chunk, newRowKey: string | Buffer): void;
    /**
     * Validates state for rowInProgress
     * @private
     * @param {chunk} chunk chunk to validate
     */
    validateRowInProgress(chunk: Chunk): void;
    /**
     * Validates chunk for cellInProgress state.
     * @private
     * @param {chunk} chunk chunk to validate
     */
    validateCellInProgress(chunk: Chunk): void;
    /**
     * Moves to next state in processing.
     * @private
     * @param {chunk} chunk chunk in process
     */
    moveToNextState(chunk: Chunk): void;
    /**
     * Process chunk when in NEW_ROW state.
     * @private
     * @param {chunks} chunk chunk to process
     */
    processNewRow(chunk: Chunk): void;
    /**
     * Process chunk when in ROW_IN_PROGRESS state.
     * @private
     * @param {chunk} chunk chunk to process
     */
    processRowInProgress(chunk: Chunk): void;
    /**
     * Process chunk when in CELl_IN_PROGRESS state.
     * @private
     * @param {chunk} chunk chunk to process
     */
    processCellInProgress(chunk: Chunk): void;
}
export {};
