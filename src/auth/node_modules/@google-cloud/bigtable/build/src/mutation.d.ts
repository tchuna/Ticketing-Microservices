/// <reference types="node" />
import { google as btTypes } from '../protos/protos';
export declare type IMutation = btTypes.bigtable.v2.IMutation;
export declare type IMutateRowRequest = btTypes.bigtable.v2.IMutateRowRequest;
export declare type ISetCell = btTypes.bigtable.v2.Mutation.ISetCell;
export declare type Bytes = string | Buffer;
export declare type Data = any;
export interface JsonObj {
    [k: string]: string | JsonObj;
}
export declare type Value = string | number | boolean;
export interface ParsedColumn {
    family: string | null;
    qualifier: string | null;
}
export interface ConvertFromBytesOptions {
    userOptions?: ConvertFromBytesUserOptions;
    isPossibleNumber?: boolean;
}
export interface ConvertFromBytesUserOptions {
    decode?: boolean;
    encoding?: BufferEncoding;
}
export interface MutationConstructorObj {
    key: string;
    method: string;
    data: Data;
}
export interface MutationSettingsObj {
    follows?: ValueObj;
    column?: string;
    time?: {
        start: Date | number;
        end: Date | number;
    };
}
export interface TimeRange {
    [k: string]: number | string | undefined;
    startTimestampMicros?: number;
    endTimestampMicros?: number;
}
export interface SetCellObj {
    [k: string]: string | ISetCell | undefined;
    setCell?: ISetCell;
}
export interface ValueObj {
    [k: string]: Buffer | Value | ValueObj;
}
/**
 * Formats table mutations to be in the expected proto format.
 *
 * @private
 *
 * @class
 * @param {object} mutation
 *
 * @example
 * ```
 * const mutation = new Mutation({
 *   key: 'gwashington',
 *   method: 'insert',
 *   data: {
 *     jadams: 1
 *   }
 * });
 * ```
 */
export declare class Mutation {
    key: string;
    method: string;
    data: Data;
    constructor(mutation: MutationConstructorObj);
    /**
     * Parses "bytes" returned from proto service.
     *
     * @param {string} bytes - Base64 encoded string.
     * @param {object} [options] Options to device return types
     * @param {boolean} [options.isPossibleNumber] Check if byte is number
     * @param {object} [options.userOptions]
     * @param {boolean} [options.userOptions.decode] Check if decode is required
     * @param {boolean} [options.userOptions.encoding] The encoding to use when
     *     converting the buffer to a string.
     * @returns {string|number|buffer}
     * @private
     */
    static convertFromBytes(bytes: Buffer | string, options?: ConvertFromBytesOptions): Buffer | Value | string;
    /**
     * Converts data into a buffer for proto service.
     *
     * @param {string} data - The data to be sent.
     * @returns {buffer}
     * @private
     */
    static convertToBytes(data: Buffer | Data): Buffer | Data;
    /**
     * Takes date objects and creates a time range.
     *
     * @param {date} start - The start date.
     * @param {date} end - The end date.
     * @returns {object}
     * @private
     */
    static createTimeRange(start: Date | number, end: Date | number): TimeRange;
    /**
     * Formats an `insert` mutation to what the proto service expects.
     *
     * @param {object} data - The entity data.
     * @returns {object[]}
     *
     * @example
     * ```
     * Mutation.encodeSetCell({
     *   follows: {
     *     gwashington: 1,
     *     alincoln: 1
     *   }
     * });
     * // [
     * //   {
     * //     setCell: {
     * //       familyName: 'follows',
     * //       columnQualifier: 'gwashington', // as buffer
     * //       timestampMicros: -1, // -1 means to use the server time
     * //       value: 1 // as buffer
     * //     }
     * //   }, {
     * //     setCell: {
     * //       familyName: 'follows',
     * //       columnQualifier: 'alincoln', // as buffer
     * //       timestampMicros: new Date(), // uses the client's current time
     * //       value: 1 // as buffer
     * //     }
     * //   }
     * // ]
     * ```
     * @private
     */
    static encodeSetCell(data: Data): SetCellObj[];
    /**
     * Formats a `delete` mutation to what the proto service expects. Depending
     * on what data is supplied to this method, it will return an object that can
     * will do one of the following:
     *
     * * Delete specific cells from a column.
     * * Delete all cells contained with a specific family.
     * * Delete all cells from an entire rows.
     *
     * @param {object} data - The entry data.
     * @returns {object}
     *
     * @example
     * ```
     * Mutation.encodeDelete([
     *   'follows:gwashington'
     * ]);
     * // {
     * //   deleteFromColumn: {
     * //     familyName: 'follows',
     * //     columnQualifier: 'gwashington', // as buffer
     * //     timeRange: null // optional
     * //   }
     * // }
     *
     * Mutation.encodeDelete([
     *   'follows'
     * ]);
     * // {
     * //   deleteFromFamily: {
     * //     familyName: 'follows'
     * //   }
     * // }
     *
     * Mutation.encodeDelete();
     * // {
     * //   deleteFromRow: {}
     * // }
     *
     * // It's also possible to specify a time range when deleting specific
     * // columns.
     *
     * Mutation.encodeDelete([
     *   {
     *     column: 'follows:gwashington',
     *     time: {
     *       start: new Date('March 21, 2000'),
     *       end: new Date('March 21, 2001')
     *     }
     *   }
     * ]);
     * ```
     * @private
     */
    static encodeDelete(data?: Data | Data[]): IMutation[];
    /**
     * Creates a new Mutation object and returns the proto JSON form.
     *
     * @param {object} mutation - The entity data.
     * @returns {object}
     * @private
     */
    static parse(mutation: Mutation): IMutateRowRequest;
    /**
     * Parses a column name into an object.
     *
     * @param {string} column - The column name.
     * @returns {object}
     *
     * @example
     * ```
     * Mutation.parseColumnName('follows:gwashington');
     * // {
     * //  family: 'follows',
     * //  qualifier: 'gwashington'
     * // }
     * ```
     * @private
     */
    static parseColumnName(columnName: string): ParsedColumn;
    /**
     * Converts the mutation object into proto friendly JSON.
     *
     * @returns {object}
     * @private
     */
    toProto(): IMutateRowRequest;
    /**
     * Mutation methods
     *
     * @private
     *
     * INSERT => setCell
     * DELETE => deleteFrom*
     */
    static methods: {
        INSERT: string;
        DELETE: string;
    };
}
