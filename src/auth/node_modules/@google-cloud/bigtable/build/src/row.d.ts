import { RawFilter } from './filter';
import { ConvertFromBytesUserOptions, Bytes, Data } from './mutation';
import { Bigtable } from '.';
import { Table, Entry, MutateCallback, MutateResponse, PartialFailureError } from './table';
import { Chunk } from './chunktransformer';
import { CallOptions } from 'google-gax';
import { ServiceError } from 'google-gax';
import { google } from '../protos/protos';
export interface Rule {
    column: string;
    append: string;
    increment?: number;
}
export interface CreateRowOptions {
    gaxOptions?: CallOptions;
    entry?: Entry;
}
export interface FormatFamiliesOptions {
    decode?: boolean;
}
export interface Family {
    name: string;
    columns: Array<{
        qualifier?: Bytes;
        cells: Array<{
            value?: Bytes;
            timestampMicros?: number;
            labels?: string[];
        }>;
    }>;
}
export interface FilterConfigOption {
    method?: string;
    data?: Data;
}
export interface FilterConfig {
    gaxOptions?: CallOptions;
    onMatch?: FilterConfigOption[];
    onNoMatch?: FilterConfigOption[];
}
export interface GetRowOptions {
    /**
     *  If set to `false` it will not decode Buffer values returned from Bigtable.
     */
    decode?: boolean;
    /**
     * Request configuration options, outlined here:
     * https://googleapis.github.io/gax-nodejs/CallSettings.html.
     */
    gaxOptions?: CallOptions;
    filter?: {};
}
export declare type RowExistsCallback = (err: ServiceError | null, exists?: boolean) => void;
export declare type RowExistsResponse = [boolean];
export declare type CreateRulesCallback = (err: ServiceError | null, apiResponse?: google.bigtable.v2.IReadModifyWriteRowResponse) => void;
export declare type CreateRulesResponse = [google.bigtable.v2.IReadModifyWriteRowResponse];
export declare type CreateRowCallback = (err: ServiceError | PartialFailureError | null, row?: Row | null, apiResponse?: google.protobuf.Empty) => void;
export declare type CreateRowResponse = [Row, google.protobuf.Empty];
export declare type GetRowMetadataCallback = (err: RowError | null, apiResponse?: google.bigtable.v2.ReadRowsResponse) => void;
export declare type GetRowMetadataResponse = [google.bigtable.v2.ReadRowsResponse];
export declare type GetRowCallback<T = Row> = (err: RowError | null, row?: T, apiResponse?: {}) => void;
export declare type GetRowResponse<T = Row> = [T, {}];
export declare type FilterCallback = (err: ServiceError | null, matched?: boolean | null, apiResponse?: google.bigtable.v2.ICheckAndMutateRowResponse) => void;
export declare type FilterResponse = [boolean | null, google.bigtable.v2.ICheckAndMutateRowResponse];
export declare type IncrementCallback = (err: ServiceError | null, value?: number | null, apiResponse?: google.bigtable.v2.IReadModifyWriteRowResponse) => void;
export declare type IncrementResponse = [number | null, google.bigtable.v2.IReadModifyWriteRowResponse];
/**
 * @private
 */
export declare class RowError extends Error {
    code: number;
    constructor(row: string);
}
/**
 * Create a Row object to interact with your table rows.
 *
 * @class
 * @param {Table} table The row's parent Table instance.
 * @param {string} key The key for this row.
 *
 * @example
 * ```
 * const {Bigtable} = require('@google-cloud/bigtable');
 * const bigtable = new Bigtable();
 * const instance = bigtable.instance('my-instance');
 * const table = instance.table('prezzy');
 * const row = table.row('gwashington');
 * ```
 */
export declare class Row {
    bigtable: Bigtable;
    table: Table;
    id: string;
    data: any;
    key?: string;
    metadata?: {};
    constructor(table: Table, key: string);
    /**
     * Formats the row chunks into friendly format. Chunks contain 3 properties:
     *
     * `rowContents` The row contents, this essentially is all data pertaining
     *     to a single family.
     *
     * `commitRow` This is a boolean telling us the all previous chunks for this
     *     row are ok to consume.
     *
     * `resetRow` This is a boolean telling us that all the previous chunks are to
     *     be discarded.
     *
     * @private
     *
     * @param {chunk[]} chunks The list of chunks.
     * @param {object} [options] Formatting options.
     *
     * @example
     * ```
     * Row.formatChunks_(chunks);
     * // {
     * //   follows: {
     * //     gwashington: [
     * //       {
     * //         value: 2
     * //       }
     * //     ]
     * //   }
     * // }
     * ```
     */
    static formatChunks_(chunks: Chunk[], options?: ConvertFromBytesUserOptions): Row[];
    /**
     * Formats a rowContents object into friendly format.
     *
     * @private
     *
     * @param {object[]} families The row families.
     * @param {object} [options] Formatting options.
     *
     * @example
     * ```
     * const families = [
     *   {
     *     name: 'follows',
     *     columns: [
     *       {
     *         qualifier: 'gwashington',
     *         cells: [
     *           {
     *             value: 2
     *           }
     *         ]
     *       }
     *     ]
     *   }
     * ];
     *
     * Row.formatFamilies_(families);
     * // {
     * //   follows: {
     * //     gwashington: [
     * //       {
     * //         value: 2
     * //       }
     * //     ]
     * //   }
     * // }
     * ```
     */
    static formatFamilies_(families: google.bigtable.v2.IFamily[], options?: FormatFamiliesOptions): {
        [index: string]: {};
    };
    create(options?: CreateRowOptions): Promise<CreateRowResponse>;
    create(options: CreateRowOptions, callback: CreateRowCallback): void;
    create(callback: CreateRowCallback): void;
    createRules(rules: Rule | Rule[], options?: CallOptions): Promise<CreateRulesResponse>;
    createRules(rules: Rule | Rule[], options: CallOptions, callback: CreateRulesCallback): void;
    createRules(rules: Rule | Rule[], callback: CreateRulesCallback): void;
    delete(options?: CallOptions): Promise<MutateResponse>;
    delete(options: CallOptions, callback: MutateCallback): void;
    delete(callback: MutateCallback): void;
    deleteCells(columns: string[], options?: CallOptions): Promise<MutateResponse>;
    deleteCells(columns: string[], options: CallOptions, callback: MutateCallback): void;
    deleteCells(columns: string[], callback: MutateCallback): void;
    exists(options?: CallOptions): Promise<RowExistsResponse>;
    exists(options: CallOptions, callback: RowExistsCallback): void;
    exists(callback: RowExistsCallback): void;
    filter(filter: RawFilter, config?: FilterConfig): Promise<FilterResponse>;
    filter(filter: RawFilter, config: FilterConfig, callback: FilterCallback): void;
    filter(filter: RawFilter, callback: FilterCallback): void;
    get(options?: GetRowOptions): Promise<GetRowResponse<Row>>;
    get<T = any>(columns: string[], options?: GetRowOptions): Promise<GetRowResponse<T>>;
    get<T = any>(columns: string[], options: GetRowOptions, callback: GetRowCallback<T>): void;
    get<T = any>(columns: string[], callback: GetRowCallback<T>): void;
    get(callback: GetRowCallback<Row>): void;
    get(options: GetRowOptions, callback: GetRowCallback<Row>): void;
    getMetadata(options?: GetRowOptions): Promise<GetRowMetadataResponse>;
    getMetadata(options: GetRowOptions, callback: GetRowMetadataCallback): void;
    getMetadata(callback: GetRowMetadataCallback): void;
    increment(column: string, value?: number): Promise<IncrementResponse>;
    increment(column: string, value: number, options?: CallOptions): Promise<IncrementResponse>;
    increment(column: string, options?: CallOptions): Promise<IncrementResponse>;
    increment(column: string, value: number, options: CallOptions, callback: IncrementCallback): void;
    increment(column: string, value: number, callback: IncrementCallback): void;
    increment(column: string, options: CallOptions, callback: IncrementCallback): void;
    increment(column: string, callback: IncrementCallback): void;
    save(entry: Entry, options?: CallOptions): Promise<MutateResponse>;
    save(entry: Entry, options: CallOptions, callback: MutateCallback): void;
    save(entry: Entry, callback: MutateCallback): void;
}
