/// <reference types="node" />
import { ServiceError } from 'google-gax';
import { PassThrough } from 'stream';
import { Family, CreateFamilyOptions, CreateFamilyCallback, CreateFamilyResponse, IColumnFamily } from './family';
import { BoundData, RawFilter } from './filter';
import { Row } from './row';
import { CallOptions } from 'google-gax';
import { Bigtable } from '.';
import { Instance } from './instance';
import { ModifiableBackupFields } from './backup';
import { CreateBackupCallback, CreateBackupResponse } from './cluster';
import { google } from '../protos/protos';
/**
 * @typedef {object} Policy
 * @property {number} [version] Specifies the format of the policy.
 *     Valid values are 0, 1, and 3. Requests specifying an invalid value will
 *     be rejected.
 *
 *     Operations affecting conditional bindings must specify version 3. This
 *     can be either setting a conditional policy, modifying a conditional
 *     binding, or removing a binding (conditional or unconditional) from the
 *     stored conditional policy.
 *     Operations on non-conditional policies may specify any valid value or
 *     leave the field unset.
 *
 *     If no etag is provided in the call to `setIamPolicy`, version compliance
 *     checks against the stored policy is skipped.
 * @property {array} [policy.bindings] Bindings associate members with roles.
 * @property {string} [policy.etag] `etag` is used for optimistic concurrency
 *     control as a way to help prevent simultaneous updates of a policy from
 *     overwriting each other. It is strongly suggested that systems make use
 *     of the `etag` in the read-modify-write cycle to perform policy updates
 *     in order to avoid raceconditions.
 */
export interface Policy {
    version?: number;
    bindings?: PolicyBinding[];
    etag?: Buffer | string;
}
/**
 * @typedef {object} PolicyBinding
 * @property {array} [PolicyBinding.role] Role that is assigned to `members`.
 *     For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
 * @property {string} [PolicyBinding.members] Identities requesting access.
 *     The full list of accepted values is outlined here
 *     https://googleapis.dev/nodejs/bigtable/latest/google.iam.v1.html#.Binding
 * @property {Expr} [PolicyBinding.condition] The condition that is associated
 *     with this binding.
 *     NOTE: An unsatisfied condition will not allow user access via current
 *     binding. Different bindings, including their conditions, are examined
 *     independently.
 */
export interface PolicyBinding {
    role?: string;
    members?: string[];
    condition?: Expr | null;
}
/**
 * @typedef {object} Expr
 * @property {string} [Expr.expression] The application context of the containing
 *     message determines which well-known feature set of Common Expression Language
 *     is supported.
 * @property {string} [Expr.title] An optional title for the expression, i.e. a
 *     short string describing its purpose. This can be used e.g. in UIs which
 *     allow to enter the expression.
 * @property {string} [Expr.description] An optional description of the
 *     expression. This is a longer text which describes the expression,
 *     e.g. when hovered over it in a UI.
 * @property {string} [Expr.location] An optional string indicating the location
 *     of the expression for error reporting, e.g. a file name and a position
 *     in the file.
 */
interface Expr {
    expression?: string;
    title?: string;
    description?: string;
    location?: string;
}
/**
 * @callback GetIamPolicyCallback
 * @param {?Error} err Request error, if any.
 * @param {object} policy The policy.
 */
export interface GetIamPolicyCallback {
    (err?: Error | null, policy?: Policy): void;
}
/**
 * @typedef {array} GetIamPolicyResponse
 * @property {object} 0 The policy.
 */
export declare type GetIamPolicyResponse = [Policy];
export interface GetIamPolicyOptions {
    gaxOptions?: CallOptions;
    requestedPolicyVersion?: 0 | 1 | 3;
}
export declare type SetIamPolicyCallback = GetIamPolicyCallback;
export declare type SetIamPolicyResponse = GetIamPolicyResponse;
/**
 * @callback TestIamPermissionsCallback
 * @param {?Error} err Request error, if any.
 * @param {string[]} permissions A subset of permissions that the caller is
 *     allowed.
 */
export interface TestIamPermissionsCallback {
    (err?: Error | null, permissions?: string[]): void;
}
/**
 * @typedef {array} TestIamPermissionsResponse
 * @property {string[]} 0 A subset of permissions that the caller is allowed.
 */
export declare type TestIamPermissionsResponse = [string[]];
export interface CreateTableOptions {
    families?: {} | string[];
    gaxOptions?: CallOptions;
    splits?: string[];
}
export declare type CreateTableCallback = (err: ServiceError | null, table?: Table, apiResponse?: google.bigtable.admin.v2.Table) => void;
export declare type CreateTableResponse = [Table, google.bigtable.admin.v2.Table];
export declare type TableExistsCallback = (err: ServiceError | null, exists?: boolean) => void;
export declare type TableExistsResponse = [boolean];
export interface GetTablesOptions {
    gaxOptions?: CallOptions;
    /**
     * View over the table's fields. Possible options are 'name', 'schema' or
     * 'full'. Default: 'name'.
     */
    view?: 'name' | 'schema' | 'full';
    pageSize?: number;
    pageToken?: string;
}
export interface GetRowsOptions {
    /**
     * If set to `false` it will not decode Buffer values returned from Bigtable.
     */
    decode?: boolean;
    /**
     * The encoding to use when converting Buffer values to a string.
     */
    encoding?: string;
    /**
     * End value for key range.
     */
    end?: string;
    /**
     * Row filters allow you to both make advanced queries and format how the data is returned.
     */
    filter?: RawFilter;
    /**
     * Request configuration options, outlined here: https://googleapis.github.io/gax-nodejs/CallSettings.html.
     */
    gaxOptions?: CallOptions;
    /**
     * A list of row keys.
     */
    keys?: string[];
    /**
     * Maximum number of rows to be returned.
     */
    limit?: number;
    /**
     * Prefix that the row key must match.
     */
    prefix?: string;
    /**
     * List of prefixes that a row key must match.
     */
    prefixes?: string[];
    /**
     * A list of key ranges.
     */
    ranges?: PrefixRange[];
    /**
     * Start value for key range.
     */
    start?: string;
}
export interface GetMetadataOptions {
    /**
     * Request configuration options, outlined here: https://googleapis.github.io/gax-nodejs/CallSettings.html.
     */
    gaxOptions?: CallOptions;
    /**
     * The view to be applied to the table fields.
     */
    view?: string;
}
export interface GetTableOptions {
    /**
     * Automatically create the instance if it does not already exist.
     */
    autoCreate?: boolean;
    /**
     * Request configuration options, outlined here: https://googleapis.github.io/gax-nodejs/CallSettings.html.
     */
    gaxOptions?: CallOptions;
}
export interface MutateOptions {
    /**
     * Request configuration options, outlined here: https://googleapis.github.io/gax-nodejs/global.html#CallOptions.
     */
    gaxOptions?: CallOptions;
    /**
     * If set to `true` will treat entriesmas a raw Mutation object. See {@link Mutation#parse}.
     */
    rawMutation?: boolean;
}
export declare type Entry = any;
export declare type DeleteTableCallback = (err: ServiceError | null, apiResponse?: google.protobuf.Empty) => void;
export declare type DeleteTableResponse = [google.protobuf.Empty];
export declare type CheckConsistencyCallback = (err: ServiceError | null, consistent?: boolean) => void;
export declare type CheckConsistencyResponse = [boolean];
export declare type GenerateConsistencyTokenCallback = (err: ServiceError | null, token?: string) => void;
export declare type GenerateConsistencyTokenResponse = [string];
export declare type WaitForReplicationCallback = (err: ServiceError | null, wait?: boolean) => void;
export declare type WaitForReplicationResponse = [boolean];
export declare type TruncateCallback = (err: ServiceError | null, apiResponse?: google.protobuf.Empty) => void;
export declare type TruncateResponse = [google.protobuf.Empty];
export declare type SampleRowKeysCallback = (err: ServiceError | null, keys?: string[]) => void;
export declare type SampleRowsKeysResponse = [string[]];
export declare type DeleteRowsCallback = (err: ServiceError | null, apiResponse?: google.protobuf.Empty) => void;
export declare type DeleteRowsResponse = [google.protobuf.Empty];
export declare type GetMetadataCallback = (err: ServiceError | null, apiResponse: google.bigtable.admin.v2.ITable) => void;
export declare type GetMetadataResponse = [google.bigtable.admin.v2.Table];
export declare type GetTableCallback = (err: ServiceError | null, table?: Table, apiResponse?: google.bigtable.admin.v2.ITable) => void;
export declare type GetTableResponse = [Table, google.bigtable.admin.v2.Table];
export declare type GetTablesCallback = (err: ServiceError | null, tables?: Table[], apiResponse?: google.bigtable.admin.v2.ITable[]) => void;
export declare type GetTablesResponse = [Table[], google.bigtable.admin.v2.Table[]];
export declare type GetFamiliesCallback = (err: ServiceError | null, families?: Family[], apiResponse?: IColumnFamily) => void;
export declare type GetFamiliesResponse = [Family[], IColumnFamily];
export declare type GetReplicationStatesCallback = (err: ServiceError | null, clusterStates?: Map<string, google.bigtable.admin.v2.Table.IClusterState>, apiResponse?: {}) => void;
export declare type GetReplicationStatesResponse = [Map<string, google.bigtable.admin.v2.Table.IClusterState>, google.bigtable.admin.v2.ITable];
export declare type GetRowsCallback = (err: ServiceError | null, rows?: Row[], apiResponse?: google.bigtable.v2.ReadRowsResponse) => void;
export declare type GetRowsResponse = [Row[], google.bigtable.v2.ReadRowsResponse];
export declare type InsertRowsCallback = (err: ServiceError | PartialFailureError | null, apiResponse?: google.protobuf.Empty) => void;
export declare type InsertRowsResponse = [google.protobuf.Empty];
export declare type MutateCallback = (err: ServiceError | PartialFailureError | null, apiResponse?: google.protobuf.Empty) => void;
export declare type MutateResponse = [google.protobuf.Empty];
export interface PrefixRange {
    start?: BoundData | string;
    end?: BoundData | string;
}
export interface CreateBackupConfig extends ModifiableBackupFields {
    gaxOptions?: CallOptions;
}
/**
 * Create a Table object to interact with a Cloud Bigtable table.
 *
 * @class
 * @param {Instance} instance Instance Object.
 * @param {string} id Unique identifier of the table.
 *
 * @example
 * ```
 * const {Bigtable} = require('@google-cloud/bigtable');
 * const bigtable = new Bigtable();
 * const instance = bigtable.instance('my-instance');
 * const table = instance.table('prezzy');
 * ```
 */
export declare class Table {
    bigtable: Bigtable;
    instance: Instance;
    name: string;
    id: string;
    metadata?: google.bigtable.admin.v2.ITable;
    maxRetries?: number;
    constructor(instance: Instance, id: string);
    /**
     * Formats the decodes policy etag value to string.
     *
     * @private
     *
     * @param {object} policy
     */
    static decodePolicyEtag(policy: Policy): Policy;
    /**
     * Formats the table name to include the Bigtable cluster.
     *
     * @private
     *
     * @param {string} instanceName The formatted instance name.
     * @param {string} name The table name.
     *
     * @example
     * ```
     * Table.formatName_(
     *   'projects/my-project/zones/my-zone/instances/my-instance',
     *   'my-table'
     * );
     * //
     * 'projects/my-project/zones/my-zone/instances/my-instance/tables/my-table'
     * ```
     */
    static formatName_(instanceName: string, id: string): string;
    /**
     * Creates a range based off of a key prefix.
     *
     * @private
     *
     * @param {string} start The key prefix/starting bound.
     * @returns {object} range
     *
     * @example
     * ```
     * const {Bigtable} = require('@google-cloud/bigtable');
     * const bigtable = new Bigtable();
     * const instance = bigtable.instance('my-instance');
     * const table = instance.table('prezzy');
     * table.createPrefixRange('start');
     * // => {
     * //   start: 'start',
     * //   end: {
     * //     value: 'staru',
     * //     inclusive: false
     * //   }
     * // }
     * ```
     */
    static createPrefixRange(start: string): PrefixRange;
    create(options?: CreateTableOptions): Promise<CreateTableResponse>;
    create(options: CreateTableOptions, callback: CreateTableCallback): void;
    create(callback: CreateTableCallback): void;
    createBackup(id: string, config: CreateBackupConfig): Promise<CreateBackupResponse>;
    createBackup(id: string, config: CreateBackupConfig, callback: CreateBackupCallback): void;
    createBackup(id: string, config: CreateBackupConfig, callback: CreateBackupCallback): void;
    createFamily(id: string, options?: CreateFamilyOptions): Promise<CreateFamilyResponse>;
    createFamily(id: string, options: CreateFamilyOptions, callback: CreateFamilyCallback): void;
    createFamily(id: string, callback: CreateFamilyCallback): void;
    /**
     * Get {@link Row} objects for the rows currently in your table as a
     * readable object stream.
     *
     * @param {object} [options] Configuration object.
     * @param {boolean} [options.decode=true] If set to `false` it will not decode
     *     Buffer values returned from Bigtable.
     * @param {boolean} [options.encoding] The encoding to use when converting
     *     Buffer values to a string.
     * @param {string} [options.end] End value for key range.
     * @param {Filter} [options.filter] Row filters allow you to
     *     both make advanced queries and format how the data is returned.
     * @param {object} [options.gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @param {string[]} [options.keys] A list of row keys.
     * @param {number} [options.limit] Maximum number of rows to be returned.
     * @param {string} [options.prefix] Prefix that the row key must match.
     * @param {string[]} [options.prefixes] List of prefixes that a row key must
     *     match.
     * @param {object[]} [options.ranges] A list of key ranges.
     * @param {string} [options.start] Start value for key range.
     * @returns {stream}
     *
     * @example <caption>include:samples/api-reference-doc-snippets/table.js</caption>
     * region_tag:bigtable_api_table_readstream
     */
    createReadStream(opts?: GetRowsOptions): PassThrough;
    delete(gaxOptions?: CallOptions): Promise<DeleteTableResponse>;
    delete(gaxOptions: CallOptions, callback: DeleteTableCallback): void;
    delete(callback: DeleteTableCallback): void;
    deleteRows(prefix: string, gaxOptions?: CallOptions): Promise<DeleteRowsResponse>;
    deleteRows(prefix: string, gaxOptions: CallOptions, callback: DeleteRowsCallback): void;
    deleteRows(prefix: string, callback: DeleteRowsCallback): void;
    exists(gaxOptions?: CallOptions): Promise<TableExistsResponse>;
    exists(gaxOptions: CallOptions, callback: TableExistsCallback): void;
    exists(callback: TableExistsCallback): void;
    /**
     * Get a reference to a Table Family.
     *
     * @throws {error} If a name is not provided.
     *
     * @param {string} id The family unique identifier.
     * @returns {Family}
     *
     * @example
     * ```
     * const family = table.family('my-family');
     * ```
     */
    family(id: string): Family;
    get(options?: GetTableOptions): Promise<GetTableResponse>;
    get(options: GetTableOptions, callback: GetTableCallback): void;
    get(callback: GetTableCallback): void;
    getIamPolicy(options?: GetIamPolicyOptions): Promise<[Policy]>;
    getIamPolicy(options: GetIamPolicyOptions, callback: GetIamPolicyCallback): void;
    getFamilies(gaxOptions?: CallOptions): Promise<GetFamiliesResponse>;
    getFamilies(gaxOptions: CallOptions, callback: GetFamiliesCallback): void;
    getFamilies(callback: GetFamiliesCallback): void;
    getReplicationStates(gaxOptions?: CallOptions): Promise<GetReplicationStatesResponse>;
    getReplicationStates(gaxOptions: CallOptions, callback: GetReplicationStatesCallback): void;
    getReplicationStates(callback: GetReplicationStatesCallback): void;
    getMetadata(options?: GetMetadataOptions): Promise<GetMetadataResponse>;
    getMetadata(options: GetMetadataOptions, callback: GetMetadataCallback): void;
    getMetadata(callback: GetMetadataCallback): void;
    getRows(options?: GetRowsOptions): Promise<GetRowsResponse>;
    getRows(options: GetRowsOptions, callback: GetRowsCallback): void;
    getRows(callback: GetRowsCallback): void;
    insert(entries: Entry | Entry[], gaxOptions?: CallOptions): Promise<InsertRowsResponse>;
    insert(entries: Entry | Entry[], gaxOptions: CallOptions, callback: InsertRowsCallback): void;
    insert(entries: Entry | Entry[], callback: InsertRowsCallback): void;
    mutate(entries: Entry | Entry[], options?: MutateOptions): Promise<MutateResponse>;
    mutate(entries: Entry | Entry[], options: MutateOptions, callback: MutateCallback): void;
    mutate(entries: Entry | Entry[], callback: MutateCallback): void;
    /**
     * Get a reference to a table row.
     *
     * @throws {error} If a key is not provided.
     *
     * @param {string} key The row key.
     * @returns {Row}
     *
     * @example
     * ```
     * const row = table.row('lincoln');
     * ```
     */
    row(key: string): Row;
    sampleRowKeys(gaxOptions?: CallOptions): Promise<SampleRowsKeysResponse>;
    sampleRowKeys(gaxOptions: CallOptions, callback: SampleRowKeysCallback): void;
    sampleRowKeys(callback?: SampleRowKeysCallback): void;
    /**
     * Returns a sample of row keys in the table as a readable object stream.
     *
     * See {@link Table#sampleRowKeys} for more details.
     *
     * @param {object} [gaxOptions] Request configuration options, outlined here:
     *     https://googleapis.github.io/gax-nodejs/CallSettings.html.
     * @returns {stream}
     *
     * @example
     * ```
     * table.sampleRowKeysStream()
     *   .on('error', console.error)
     *   .on('data', function(key) {
     *     // Do something with the `key` object.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing.
     * //-
     * table.sampleRowKeysStream()
     *   .on('data', function(key) {
     *     this.end();
     *   });
     * ```
     */
    sampleRowKeysStream(gaxOptions?: CallOptions): any;
    setIamPolicy(policy: Policy, gaxOptions?: CallOptions): Promise<SetIamPolicyResponse>;
    setIamPolicy(policy: Policy, callback: SetIamPolicyCallback): void;
    setIamPolicy(policy: Policy, gaxOptions: CallOptions, callback: SetIamPolicyCallback): void;
    testIamPermissions(permissions: string | string[], gaxOptions?: CallOptions): Promise<TestIamPermissionsResponse>;
    testIamPermissions(permissions: string | string[], callback: TestIamPermissionsCallback): void;
    testIamPermissions(permissions: string | string[], gaxOptions: CallOptions, callback: TestIamPermissionsCallback): void;
    truncate(gaxOptions?: CallOptions): Promise<TruncateResponse>;
    truncate(gaxOptions: CallOptions, callback: TruncateCallback): void;
    truncate(callback: TruncateCallback): void;
    waitForReplication(): Promise<WaitForReplicationResponse>;
    waitForReplication(callback: WaitForReplicationCallback): void;
    generateConsistencyToken(): Promise<GenerateConsistencyTokenResponse>;
    generateConsistencyToken(callback: GenerateConsistencyTokenCallback): void;
    checkConsistency(token: string): Promise<CheckConsistencyResponse>;
    checkConsistency(token: string, callback: CheckConsistencyCallback): void;
    /**
     * The view to be applied to the returned table's fields.
     * Defaults to schema if unspecified.
     *
     * @private
     */
    static VIEWS: {
        [index: string]: number;
    };
}
export interface GoogleInnerError {
    reason?: string;
    message?: string;
}
export declare class PartialFailureError extends Error {
    errors?: GoogleInnerError[];
    constructor(errors: GoogleInnerError[], rpcError?: ServiceError | null);
}
export {};
